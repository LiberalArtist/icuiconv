#lang zuo
;; SPDX-License-Identifier: Apache-2.0
;; SPDX-FileCopyrightText:  2023 Philip McGrath <philip@philipmcgrath.com>

(provide-targets targets-at)

(define iconv-txt (at-source "iconv--list.txt"))
(define extra-txt (at-source "iconv--list--enable-extra-encodings.txt"))
(define uconv-txt (at-source "uconv--list.txt"))

(define (targets-at at-dir vars)
  (define encodings.ss (at-dir "encodings.ss"))
  (define missing-encodings.ss (at-dir "missing-encodings.ss"))
  (make-targets
   `([:target ,missing-encodings.ss (,encodings.ss)
              ,(lambda (dest token)
                 (display-to-file (~a ";; This file was generated by Zuo.\n"
                                      (encodings-table->string
                                       (encodings-table->missing
                                        (car (string-read (file->string
                                                           encodings.ss)
                                                          0
                                                          encodings.ss)))))
                                  dest
                                  :truncate))]
     [:target ,encodings.ss (,iconv-txt ,extra-txt ,uconv-txt)
              ,(lambda (dest token)
                 (display-to-file (~a ";; This file was generated by Zuo.\n"
                                      (encodings-table->string
                                       (build-encodings-table)))
                                  dest
                                  :truncate))]
     [:target clean ()
              ,(lambda (token)
                 (for-each rm* (list encodings.ss
                                     missing-encodings.ss)))])))

;; https://www.gnu.org/software/libiconv/documentation/libiconv-1.13/iconv.1.html
;; "The `iconv −l` or `iconv −−list` command lists the names of the supported
;; encodings, in a system dependent format. For the libiconv implementation,
;; the names are printed in upper case, separated by whitespace, and alias
;; names of an encoding are listed on the same line as the encoding itself."

;; https://manpages.debian.org/bookworm/icu-devtools/uconv.1.en.html

;; parse-libiconv-list-string : String -> (Listof (Nonempty-Listof String))
;; Takes the full output of `iconv --list` or `uconv --list` as a string
;; (the formats are close enough) and returns a list of alias groups.
(define (parse-encodings-list str)
  (define (no-cr str)
    (string-join (string-split str "\r") ""))
  (filter pair?
          (map (lambda (line)
                 (string-split line))
               (string-split (no-cr str) "\n"))))

;; build-encodings-table
;; Returns something like `((iconv ([("alias" ...+) "uconv"] ...+))
;;                          (extra ([("alias" ...+) #f] ...+)))
(define (build-encodings-table)
  (define iconv (parse-encodings-list (file->string iconv-txt)))
  (define extra (parse-encodings-list (file->string extra-txt)))
  (define uconv (parse-encodings-list (file->string uconv-txt)))
  (map (lambda (name from)
         (list name (match-aliases from uconv)))
       '(iconv extra)
       (partition (lambda (group)
                    (member group iconv))
                  extra)))

;; encodings-table->missing
;; Given a list like the result of `(build-encodings-table)`,
;; filters it to only the entries mapped to `#f`.
(define (encodings-table->missing encs)
  (map (lambda (section)
         (list (car section)
               (filter (lambda (mapping)
                         (not (cadr mapping)))
                       (cadr section))))
       encs))

;; match-aliases :
;;   (Listof (Nonempty-Listof String)) (Listof (Nonempty-Listof String))
;;   -> (Listof (List (Nonempty-Listof String) (U #f String)))
;; Returns a list like `from`, but with each alias group mapped to
;; the name of an encoding in `to` or to `#f` if none exists.
(define (match-aliases from to)
  (map (lambda (from-group)
         (list from-group
               (ormap (lambda (to-group)
                        (ormap (lambda (from-alias)
                                 (ormap (lambda (to-alias)
                                          (and (string-ci=? from-alias
                                                            to-alias)
                                               from-alias))
                                        to-group))
                               from-group))
                      to)))
       from))

(define (partition pred lst)
  (if (null? lst)
      `(() ())
      (let* ((this (car lst))
             (rst (partition pred (cdr lst)))
             (yes (car rst))
             (no (cadr rst)))
        (if (pred this)
            (list (cons this yes) no)
            (list yes (cons this no))))))

(define (encodings-table->string encs)
  (string-join
   (apply
    append
    (map (lambda (section)
           (define name (car section))
           (define lst (cadr section))
           (map (lambda (mapping pos)
                  (define aliases (car mapping))
                  (define rhs (cadr mapping))
                  (~a (if (eq? 'first pos)
                          (~a (if (eq? 'iconv name)
                                  "(("
                                  " (")
                              name
                              "\n  (")
                          "   ")
                      "["
                      (render-aliases aliases)
                      "\n    "
                      (~s rhs)
                      "]"
                      (if (eq? 'last pos)
                          (if (eq? 'iconv name)
                              "))"
                              ")))\n")
                          "")))
                lst
                (cons 'first (cdr (reverse (cons 'last (cdr lst)))))))
         encs))
   "\n"))

(define fill-column 78)
(define left-offset (string-length "((([("))
(define target-length (- fill-column left-offset))

(define (render-aliases aliases)
  (~a "(" (let loop ([pos 0]
                     [aliases (map ~s aliases)])
            (define this (car aliases))
            (define rest (cdr aliases))
            (define new-pos
              (+ pos
                 (if (= 0 pos) 0 1)
                 (string-length this)
                 (if (pair? rest) 0 1)))
            (if (<= new-pos target-length)
                (~a (if (= 0 pos) "" " ")
                    this
                    (if (pair? rest)
                        (loop new-pos rest)
                        ")"))
                (~a "\n     " (loop 0 aliases))))))
